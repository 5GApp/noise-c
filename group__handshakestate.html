<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Noise-C: HandshakeState API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Noise-C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HandshakeState API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga00fef5d2b365025653ceea29f9fcd8d5"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="internal_8h.html#structNoiseHandshakeState__s">NoiseHandshakeState_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a></td></tr>
<tr class="memdesc:ga00fef5d2b365025653ceea29f9fcd8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque object that represents a HandshakeState.  <a href="#ga00fef5d2b365025653ceea29f9fcd8d5">More...</a><br/></td></tr>
<tr class="separator:ga00fef5d2b365025653ceea29f9fcd8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaaf2e6ef61771c7fa5c4f5d5e106c603"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603">noise_handshakestate_fallback</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:gaaaf2e6ef61771c7fa5c4f5d5e106c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Falls back to the "XXfallback" handshake pattern.  <a href="#gaaaf2e6ef61771c7fa5c4f5d5e106c603">More...</a><br/></td></tr>
<tr class="separator:gaaaf2e6ef61771c7fa5c4f5d5e106c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee4331d10a6c28bd336bfdf1017346d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga1ee4331d10a6c28bd336bfdf1017346d">noise_handshakestate_free</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga1ee4331d10a6c28bd336bfdf1017346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a HandshakeState object after destroying all sensitive material.  <a href="#ga1ee4331d10a6c28bd336bfdf1017346d">More...</a><br/></td></tr>
<tr class="separator:ga1ee4331d10a6c28bd336bfdf1017346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e785f9102ce47f97292bbb897ace66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66">noise_handshakestate_get_action</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga34e785f9102ce47f97292bbb897ace66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next action the application should perform for the handshake phase of the protocol.  <a href="#ga34e785f9102ce47f97292bbb897ace66">More...</a><br/></td></tr>
<tr class="separator:ga34e785f9102ce47f97292bbb897ace66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e8128e80e665ea5752833f0cb30fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dhstate.html#gacd53cb04a20ac2ee334693c4b4248956">NoiseDHState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga08e8128e80e665ea5752833f0cb30fdf">noise_handshakestate_get_fixed_ephemeral_dh</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga08e8128e80e665ea5752833f0cb30fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the DHStatic object that contains the local ephemeral keypair.  <a href="#ga08e8128e80e665ea5752833f0cb30fdf">More...</a><br/></td></tr>
<tr class="separator:ga08e8128e80e665ea5752833f0cb30fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25cdb5ceb457746f8bf5c99d3596bd00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga25cdb5ceb457746f8bf5c99d3596bd00">noise_handshakestate_get_handshake_hash</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state, uint8_t *hash, size_t max_len)</td></tr>
<tr class="memdesc:ga25cdb5ceb457746f8bf5c99d3596bd00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the handshake hash value once the handshake ends.  <a href="#ga25cdb5ceb457746f8bf5c99d3596bd00">More...</a><br/></td></tr>
<tr class="separator:ga25cdb5ceb457746f8bf5c99d3596bd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d54d2d642d3893dd8392a6bc6b30a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dhstate.html#gacd53cb04a20ac2ee334693c4b4248956">NoiseDHState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga7d54d2d642d3893dd8392a6bc6b30a22">noise_handshakestate_get_local_keypair_dh</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga7d54d2d642d3893dd8392a6bc6b30a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the DHStatic object that contains the local static keypair.  <a href="#ga7d54d2d642d3893dd8392a6bc6b30a22">More...</a><br/></td></tr>
<tr class="separator:ga7d54d2d642d3893dd8392a6bc6b30a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba0bc0e82c4ec5cbbb1a7be41164959"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga8ba0bc0e82c4ec5cbbb1a7be41164959">noise_handshakestate_get_protocol_id</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state, <a class="el" href="group__names.html#structNoiseProtocolId">NoiseProtocolId</a> *id)</td></tr>
<tr class="memdesc:ga8ba0bc0e82c4ec5cbbb1a7be41164959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the protocol identifier associated with a HandshakeState object.  <a href="#ga8ba0bc0e82c4ec5cbbb1a7be41164959">More...</a><br/></td></tr>
<tr class="separator:ga8ba0bc0e82c4ec5cbbb1a7be41164959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e34b02757ddef3481caccf85c9a1d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__dhstate.html#gacd53cb04a20ac2ee334693c4b4248956">NoiseDHState</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga1e34b02757ddef3481caccf85c9a1d54">noise_handshakestate_get_remote_public_key_dh</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga1e34b02757ddef3481caccf85c9a1d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the DHStatic object that contains the remote static public key.  <a href="#ga1e34b02757ddef3481caccf85c9a1d54">More...</a><br/></td></tr>
<tr class="separator:ga1e34b02757ddef3481caccf85c9a1d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae67e24a470c7f6a24f0aa24991114b92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gae67e24a470c7f6a24f0aa24991114b92">noise_handshakestate_get_role</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:gae67e24a470c7f6a24f0aa24991114b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the role that a HandshakeState object is playing.  <a href="#gae67e24a470c7f6a24f0aa24991114b92">More...</a><br/></td></tr>
<tr class="separator:gae67e24a470c7f6a24f0aa24991114b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3667a7038035ae31cd7629ed13f99d39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga3667a7038035ae31cd7629ed13f99d39">noise_handshakestate_has_local_keypair</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga3667a7038035ae31cd7629ed13f99d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState has been configured with a local keypair.  <a href="#ga3667a7038035ae31cd7629ed13f99d39">More...</a><br/></td></tr>
<tr class="separator:ga3667a7038035ae31cd7629ed13f99d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf8228683e002acff6690a000c12854"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga0cf8228683e002acff6690a000c12854">noise_handshakestate_has_pre_shared_key</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga0cf8228683e002acff6690a000c12854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState object has already been configured with a pre shared key.  <a href="#ga0cf8228683e002acff6690a000c12854">More...</a><br/></td></tr>
<tr class="separator:ga0cf8228683e002acff6690a000c12854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d077b55567c999bfda4662515e3154"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga46d077b55567c999bfda4662515e3154">noise_handshakestate_has_remote_public_key</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga46d077b55567c999bfda4662515e3154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState has a remote public key.  <a href="#ga46d077b55567c999bfda4662515e3154">More...</a><br/></td></tr>
<tr class="separator:ga46d077b55567c999bfda4662515e3154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7d3a6990a63b42f86109f5044c9f4d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gac7d3a6990a63b42f86109f5044c9f4d6">noise_handshakestate_needs_local_keypair</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:gac7d3a6990a63b42f86109f5044c9f4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState still needs to be configured with a local keypair.  <a href="#gac7d3a6990a63b42f86109f5044c9f4d6">More...</a><br/></td></tr>
<tr class="separator:gac7d3a6990a63b42f86109f5044c9f4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bf0e9e6b6d77262b579e5c3430f9a93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga7bf0e9e6b6d77262b579e5c3430f9a93">noise_handshakestate_needs_pre_shared_key</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga7bf0e9e6b6d77262b579e5c3430f9a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState object requires a pre shared key.  <a href="#ga7bf0e9e6b6d77262b579e5c3430f9a93">More...</a><br/></td></tr>
<tr class="separator:ga7bf0e9e6b6d77262b579e5c3430f9a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d88e66873413c052b05f7ad35827f1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga9d88e66873413c052b05f7ad35827f1b">noise_handshakestate_needs_remote_public_key</a> (const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga9d88e66873413c052b05f7ad35827f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState still needs to be configured with a remote public key before the protocol can start.  <a href="#ga9d88e66873413c052b05f7ad35827f1b">More...</a><br/></td></tr>
<tr class="separator:ga9d88e66873413c052b05f7ad35827f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b47aa4e0577b68ad90848565c00a8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gab0b47aa4e0577b68ad90848565c00a8b">noise_handshakestate_new_by_id</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> **state, const <a class="el" href="group__names.html#structNoiseProtocolId">NoiseProtocolId</a> *protocol_id, int role)</td></tr>
<tr class="memdesc:gab0b47aa4e0577b68ad90848565c00a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new HandshakeState object by protocol identifier.  <a href="#gab0b47aa4e0577b68ad90848565c00a8b">More...</a><br/></td></tr>
<tr class="separator:gab0b47aa4e0577b68ad90848565c00a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6235ea4b4c8c434417172a764bf76c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga0e6235ea4b4c8c434417172a764bf76c">noise_handshakestate_new_by_name</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> **state, const char *protocol_name, int role)</td></tr>
<tr class="memdesc:ga0e6235ea4b4c8c434417172a764bf76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new HandshakeState object by protocol name.  <a href="#ga0e6235ea4b4c8c434417172a764bf76c">More...</a><br/></td></tr>
<tr class="separator:ga0e6235ea4b4c8c434417172a764bf76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b86560fccec5c8d9051fa6e30e7cb20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga5b86560fccec5c8d9051fa6e30e7cb20">noise_handshakestate_read_message</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state, <a class="el" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> *message, <a class="el" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> *payload)</td></tr>
<tr class="memdesc:ga5b86560fccec5c8d9051fa6e30e7cb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a message payload using a HandshakeState.  <a href="#ga5b86560fccec5c8d9051fa6e30e7cb20">More...</a><br/></td></tr>
<tr class="separator:ga5b86560fccec5c8d9051fa6e30e7cb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca896117ad9a8697a3fe385deb3c280"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280">noise_handshakestate_set_pre_shared_key</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state, const uint8_t *key, size_t key_len)</td></tr>
<tr class="memdesc:gafca896117ad9a8697a3fe385deb3c280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pre shared key for a HandshakeState.  <a href="#gafca896117ad9a8697a3fe385deb3c280">More...</a><br/></td></tr>
<tr class="separator:gafca896117ad9a8697a3fe385deb3c280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1a461a40326f8db0b7a537dc63e6fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gaaf1a461a40326f8db0b7a537dc63e6fa">noise_handshakestate_set_prologue</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state, const void *prologue, size_t prologue_len)</td></tr>
<tr class="memdesc:gaaf1a461a40326f8db0b7a537dc63e6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the prologue for a HandshakeState.  <a href="#gaaf1a461a40326f8db0b7a537dc63e6fa">More...</a><br/></td></tr>
<tr class="separator:gaaf1a461a40326f8db0b7a537dc63e6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8480d1f1782d27eb6187075f1170dfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb">noise_handshakestate_split</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state, <a class="el" href="group__cipherstate.html#gaed43ed8af5dd6f1a8ce2246c5bb00dc1">NoiseCipherState</a> **c1, <a class="el" href="group__cipherstate.html#gaed43ed8af5dd6f1a8ce2246c5bb00dc1">NoiseCipherState</a> **c2)</td></tr>
<tr class="memdesc:gae8480d1f1782d27eb6187075f1170dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the transport encryption CipherState objects out of this HandshakeState object.  <a href="#gae8480d1f1782d27eb6187075f1170dfb">More...</a><br/></td></tr>
<tr class="separator:gae8480d1f1782d27eb6187075f1170dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76831b18d6d95f7f47986d2c8f873c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0">noise_handshakestate_start</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:gaf76831b18d6d95f7f47986d2c8f873c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the handshake on a HandshakeState object.  <a href="#gaf76831b18d6d95f7f47986d2c8f873c0">More...</a><br/></td></tr>
<tr class="separator:gaf76831b18d6d95f7f47986d2c8f873c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb5b38ecaf77c7c39e0aad49cf880b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gafdb5b38ecaf77c7c39e0aad49cf880b6">noise_handshakestate_write_message</a> (<a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *state, <a class="el" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> *message, const <a class="el" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> *payload)</td></tr>
<tr class="memdesc:gafdb5b38ecaf77c7c39e0aad49cf880b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message payload using a HandshakeState.  <a href="#gafdb5b38ecaf77c7c39e0aad49cf880b6">More...</a><br/></td></tr>
<tr class="separator:gafdb5b38ecaf77c7c39e0aad49cf880b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>See the <a class="el" href="example_echo.html">echo example</a> for an overview of how to use this API. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga00fef5d2b365025653ceea29f9fcd8d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque object that represents a HandshakeState. </p>

<p>Definition at line <a class="el" href="handshakestate_8h_source.html#l00033">33</a> of file <a class="el" href="handshakestate_8h_source.html">handshakestate.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaaaf2e6ef61771c7fa5c4f5d5e106c603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_fallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Falls back to the "XXfallback" handshake pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on error. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the previous protocol has not been started or has not reached the fallback position yet. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the new protocol name is too long. </dd>
<dd>
NOISE_ERROR_NOT_APPLICABLE if the handshake pattern in the original protocol name was not "IK".</dd></dl>
<p>This function is used to help implement the "Noise Pipes" protocol. It resets a HandshakeState object with the handshake pattern "IK", converting it into an object with the handshake pattern "XXfallback". Information from the previous session such as the local keypair and the initiator's ephemeral key are passed to the new session.</p>
<p>Once the fallback has been initiated, the application must call <a class="el" href="group__handshakestate.html#gaaf1a461a40326f8db0b7a537dc63e6fa" title="Sets the prologue for a HandshakeState. ">noise_handshakestate_set_prologue()</a> and <a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280" title="Sets the pre shared key for a HandshakeState. ">noise_handshakestate_set_pre_shared_key()</a> again to re-establish the early handshake details. The application can then call <a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0" title="Starts the handshake on a HandshakeState object. ">noise_handshakestate_start()</a> to restart the handshake from where it left off before the fallback.</p>
<dl class="section note"><dt>Note</dt><dd>This function reverses the roles of initiator and responder, which will also affect the ordering of the final CipherState objects returned by <a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb" title="Splits the transport encryption CipherState objects out of this HandshakeState object. ">noise_handshakestate_split()</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0" title="Starts the handshake on a HandshakeState object. ">noise_handshakestate_start()</a>, <a class="el" href="group__handshakestate.html#gae67e24a470c7f6a24f0aa24991114b92" title="Gets the role that a HandshakeState object is playing. ">noise_handshakestate_get_role()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00726">726</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ee4331d10a6c28bd336bfdf1017346d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a HandshakeState object after destroying all sensitive material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> is NULL.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gab0b47aa4e0577b68ad90848565c00a8b" title="Creates a new HandshakeState object by protocol identifier. ">noise_handshakestate_new_by_id()</a>, <a class="el" href="group__handshakestate.html#ga0e6235ea4b4c8c434417172a764bf76c" title="Creates a new HandshakeState object by protocol name. ">noise_handshakestate_new_by_name()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00242">242</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga34e785f9102ce47f97292bbb897ace66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_action </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next action the application should perform for the handshake phase of the protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ACTION_NONE if no action needs to be taken by the application because the protocol hasn't started yet. </dd>
<dd>
NOISE_ACTION_WRITE_MESSAGE if the application is expected to write a new message payload for the next outgoing handshake message using <a class="el" href="group__handshakestate.html#gafdb5b38ecaf77c7c39e0aad49cf880b6" title="Writes a message payload using a HandshakeState. ">noise_handshakestate_write_message()</a>. </dd>
<dd>
NOISE_ACTION_READ_MESSAGE if the application is expected wait for an incoming handshake message from the remote party and then pass the message to <a class="el" href="group__handshakestate.html#ga5b86560fccec5c8d9051fa6e30e7cb20" title="Reads a message payload using a HandshakeState. ">noise_handshakestate_read_message()</a> to extract the payload. </dd>
<dd>
NOISE_ACTION_FAILED if the handshake has failed with an error. The application should destroy the HandshakeState by calling <a class="el" href="group__handshakestate.html#ga1ee4331d10a6c28bd336bfdf1017346d" title="Frees a HandshakeState object after destroying all sensitive material. ">noise_handshakestate_free()</a> and terminate the connection. If the application is using Noise Pipes, then it may be able to continue by calling <a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603" title="Falls back to the &quot;XXfallback&quot; handshake pattern. ">noise_handshakestate_fallback()</a> depending upon where in the protocol the failure occurred. </dd>
<dd>
NOISE_ACTION_SPLIT if the handshake has finished successfully and the application should call <a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb" title="Splits the transport encryption CipherState objects out of this HandshakeState object. ">noise_handshakestate_split()</a> to obtain the CipherState objects for the data phase of the protocol.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gafdb5b38ecaf77c7c39e0aad49cf880b6" title="Writes a message payload using a HandshakeState. ">noise_handshakestate_write_message()</a>, <a class="el" href="group__handshakestate.html#ga5b86560fccec5c8d9051fa6e30e7cb20" title="Reads a message payload using a HandshakeState. ">noise_handshakestate_read_message()</a>, <a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb" title="Splits the transport encryption CipherState objects out of this HandshakeState object. ">noise_handshakestate_split()</a>, <a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603" title="Falls back to the &quot;XXfallback&quot; handshake pattern. ">noise_handshakestate_fallback()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00831">831</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga08e8128e80e665ea5752833f0cb30fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dhstate.html#gacd53cb04a20ac2ee334693c4b4248956">NoiseDHState</a>* noise_handshakestate_get_fixed_ephemeral_dh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the DHStatic object that contains the local ephemeral keypair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the DHState object for the local ephemeral keypair, or NULL if the system is out of memory or <em>state</em> is NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is intended for testing only. It can be used to establish a fixed ephemeral key for test vectors. This function should not be used in real applications.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga7d54d2d642d3893dd8392a6bc6b30a22" title="Gets the DHStatic object that contains the local static keypair. ">noise_handshakestate_get_local_keypair_dh()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00358">358</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga25cdb5ceb457746f8bf5c99d3596bd00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_handshake_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the handshake hash value once the handshake ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">hash</td><td>The buffer to receive the handshake hash value. </td></tr>
    <tr><td class="paramname">max_len</td><td>The maximum length of the <em>hash</em> buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>hash</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the handshake has not successfully completed yet.</dd></dl>
<p>If <em>max_len</em> is greater than the length of the handshake hash, then the extra bytes will be filled with zeroes. If <em>max_len</em> is less than the length of the handshake hash, then the value will be truncated to the first <em>max_len</em> bytes. Handshake hashes are typically 32 or 64 bytes in length, depending upon the hash algorithm that was used during the protocol.</p>
<p>The handshake hash can be used to implement "channel binding". The value will be a unique identifier for the session.</p>
<dl class="section note"><dt>Note</dt><dd>The handshake hash is generated from publicly-known values in the handshake. If the application needs a unique secret identifier, then it should combine the handshake hash with other randomly generated data that is sent encrypted during the session.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb" title="Splits the transport encryption CipherState objects out of this HandshakeState object. ">noise_handshakestate_split()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l01356">1356</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d54d2d642d3893dd8392a6bc6b30a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dhstate.html#gacd53cb04a20ac2ee334693c4b4248956">NoiseDHState</a>* noise_handshakestate_get_local_keypair_dh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the DHStatic object that contains the local static keypair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the DHState object for the local static keypair, or NULL if the handshake does not require a local static keypair.</dd></dl>
<p>The application uses the returned object to set the static keypair for the local end of the handshake if one is required.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga1e34b02757ddef3481caccf85c9a1d54" title="Gets the DHStatic object that contains the remote static public key. ">noise_handshakestate_get_remote_public_key_dh()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00317">317</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ba0bc0e82c4ec5cbbb1a7be41164959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_protocol_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__names.html#structNoiseProtocolId">NoiseProtocolId</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the protocol identifier associated with a HandshakeState object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">id</td><td>Return buffer for the protocol identifier, which consists of fields that identify the cipher algorithm, hash algorith, handshake pattern, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>id</em> is NULL. </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00292">292</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1e34b02757ddef3481caccf85c9a1d54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__dhstate.html#gacd53cb04a20ac2ee334693c4b4248956">NoiseDHState</a>* noise_handshakestate_get_remote_public_key_dh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the DHStatic object that contains the remote static public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the DHState object for the remote static public key, or NULL if the handshake does not require a remote public key.</dd></dl>
<p>The application uses the returned object to set the public key for the remote end of the handshake if the key must be provided prior to the handshake. The returned object can also be used to obtain the public key value that was transmitted by the remote party during the handshake.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga7d54d2d642d3893dd8392a6bc6b30a22" title="Gets the DHStatic object that contains the local static keypair. ">noise_handshakestate_get_local_keypair_dh()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00338">338</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae67e24a470c7f6a24f0aa24991114b92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_role </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the role that a HandshakeState object is playing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns one of NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER if <em>state</em> is non-NULL, or zero if <em>state</em> is NULL. </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00275">275</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3667a7038035ae31cd7629ed13f99d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_has_local_keypair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState has been configured with a local keypair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the <em>state</em> has already been configured with a local keypair, or 0 if the keypair is yet to be provided. Also returns zero if <em>state</em> is NULL.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gac7d3a6990a63b42f86109f5044c9f4d6" title="Determine if a HandshakeState still needs to be configured with a local keypair. ">noise_handshakestate_needs_local_keypair()</a>, <a class="el" href="group__handshakestate.html#ga7d54d2d642d3893dd8392a6bc6b30a22" title="Gets the DHStatic object that contains the local static keypair. ">noise_handshakestate_get_local_keypair_dh()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00544">544</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0cf8228683e002acff6690a000c12854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_has_pre_shared_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState object has already been configured with a pre shared key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if <em>state</em> requires a pre shared key, zero if not.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280" title="Sets the pre shared key for a HandshakeState. ">noise_handshakestate_set_pre_shared_key()</a>, <a class="el" href="group__handshakestate.html#ga7bf0e9e6b6d77262b579e5c3430f9a93" title="Determine if a HandshakeState object requires a pre shared key. ">noise_handshakestate_needs_pre_shared_key()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00404">404</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga46d077b55567c999bfda4662515e3154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_has_remote_public_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState has a remote public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the <em>state</em> has a remote public key, or 0 if the key is yet to be seen. Also returns zero if <em>state</em> is NULL.</dd></dl>
<p>A remote public key may either be provided ahead of time on the <a class="el" href="group__handshakestate.html#ga1e34b02757ddef3481caccf85c9a1d54" title="Gets the DHStatic object that contains the remote static public key. ">noise_handshakestate_get_remote_public_key_dh()</a> object, or it may be provided by the remote party during the handshake.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga9d88e66873413c052b05f7ad35827f1b" title="Determine if a HandshakeState still needs to be configured with a remote public key before the protoc...">noise_handshakestate_needs_remote_public_key()</a>, noise_handshakestate_set_remote_public_key() </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00594">594</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac7d3a6990a63b42f86109f5044c9f4d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_needs_local_keypair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState still needs to be configured with a local keypair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the <em>state</em> has not yet been configured with a local keypair, or 0 if the keypair has been provided or is not required at all. Also returns zero if <em>state</em> is NULL.</dd></dl>
<p>The application configures the local keypair on the object returned by <a class="el" href="group__handshakestate.html#ga7d54d2d642d3893dd8392a6bc6b30a22" title="Gets the DHStatic object that contains the local static keypair. ">noise_handshakestate_get_local_keypair_dh()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga3667a7038035ae31cd7629ed13f99d39" title="Determine if a HandshakeState has been configured with a local keypair. ">noise_handshakestate_has_local_keypair()</a>, <a class="el" href="group__handshakestate.html#ga7d54d2d642d3893dd8392a6bc6b30a22" title="Gets the DHStatic object that contains the local static keypair. ">noise_handshakestate_get_local_keypair_dh()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00522">522</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7bf0e9e6b6d77262b579e5c3430f9a93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_needs_pre_shared_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState object requires a pre shared key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if <em>state</em> requires a pre shared key, zero if the pre shared key has already been supplied or it is not required.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280" title="Sets the pre shared key for a HandshakeState. ">noise_handshakestate_set_pre_shared_key()</a>, <a class="el" href="group__handshakestate.html#ga0cf8228683e002acff6690a000c12854" title="Determine if a HandshakeState object has already been configured with a pre shared key...">noise_handshakestate_has_pre_shared_key()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00385">385</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d88e66873413c052b05f7ad35827f1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_needs_remote_public_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState still needs to be configured with a remote public key before the protocol can start. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the <em>state</em> has not yet been configured with a required remote public key, or 0 if the key has been provided or is not required at all. Also returns zero if <em>state</em> is NULL.</dd></dl>
<p>This function indicates that a remote public key must be supplied before the protocol starts. If it is possible for the remote public key to be provided by the remote party during the session, then the remote public key can be obtained at the end of the handshake using the <a class="el" href="group__handshakestate.html#ga1e34b02757ddef3481caccf85c9a1d54" title="Gets the DHStatic object that contains the remote static public key. ">noise_handshakestate_get_remote_public_key_dh()</a> object.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga46d077b55567c999bfda4662515e3154" title="Determine if a HandshakeState has a remote public key. ">noise_handshakestate_has_remote_public_key()</a>, <a class="el" href="group__handshakestate.html#ga1e34b02757ddef3481caccf85c9a1d54" title="Gets the DHStatic object that contains the remote static public key. ">noise_handshakestate_get_remote_public_key_dh()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00570">570</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab0b47aa4e0577b68ad90848565c00a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_new_by_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> **&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__names.html#structNoiseProtocolId">NoiseProtocolId</a> *&#160;</td>
          <td class="paramname"><em>protocol_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new HandshakeState object by protocol identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Points to the variable where to store the pointer to the new HandshakeState object. </td></tr>
    <tr><td class="paramname">protocol_id</td><td>The protocol identifier as a set of algorithm identifiers. </td></tr>
    <tr><td class="paramname">role</td><td>The role for the new object, either NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if either <em>state</em> or <em>protocol_id</em> is NULL, or <em>role</em> is not one of NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER. </dd>
<dd>
NOISE_ERROR_UNKNOWN_ID if the <em>protocol_id</em> is unknown. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the full name corresponding to <em>protocol_id</em> is too long. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the lengths of the hash output or the cipher key are incompatible. </dd>
<dd>
NOISE_ERROR_NO_MEMORY if there is insufficient memory to allocate the new HandshakeState object.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga1ee4331d10a6c28bd336bfdf1017346d" title="Frees a HandshakeState object after destroying all sensitive material. ">noise_handshakestate_free()</a>, <a class="el" href="group__handshakestate.html#ga0e6235ea4b4c8c434417172a764bf76c" title="Creates a new HandshakeState object by protocol name. ">noise_handshakestate_new_by_name()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00163">163</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e6235ea4b4c8c434417172a764bf76c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_new_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> **&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>protocol_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new HandshakeState object by protocol name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Points to the variable where to store the pointer to the new HandshakeState object. </td></tr>
    <tr><td class="paramname">protocol_name</td><td>The name of the Noise protocol to use. This string must be NUL-terminated. </td></tr>
    <tr><td class="paramname">role</td><td>The role for the new object, either NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if either <em>state</em> or <em>protocol_name</em> is NULL, or <em>role</em> is not one of NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER. </dd>
<dd>
NOISE_ERROR_UNKNOWN_NAME if the <em>protocol_name</em> is unknown. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the lengths of the hash output or the cipher key are incompatible. </dd>
<dd>
NOISE_ERROR_NO_MEMORY if there is insufficient memory to allocate the new HandshakeState object.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga1ee4331d10a6c28bd336bfdf1017346d" title="Frees a HandshakeState object after destroying all sensitive material. ">noise_handshakestate_free()</a>, <a class="el" href="group__handshakestate.html#gab0b47aa4e0577b68ad90848565c00a8b" title="Creates a new HandshakeState object by protocol identifier. ">noise_handshakestate_new_by_id()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00209">209</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b86560fccec5c8d9051fa6e30e7cb20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_read_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a message payload using a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">message</td><td>Points to the incoming handshake message to be unpacked. </td></tr>
    <tr><td class="paramname">payload</td><td>Points to the buffer to fill with the message payload. This can be NULL if the application does not need the message payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>message</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a> is not NOISE_ACTION_READ_MESSAGE. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the size of <em>message</em> is incorrect for the type of handshake packet that we expect. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the size of <em>payload</em> is too small to contain all of the payload bytes that were present in the <em>message</em>. </dd>
<dd>
NOISE_ERROR_MAC_FAILURE if the <em>message</em> failed to authenticate, which terminates the handshake. </dd>
<dd>
NOISE_ERROR_PUBLIC_KEY if an invalid remote public key is seen during the processing of this message.</dd></dl>
<p>If <em>payload</em> is NULL, then the message payload will be authenticated and then discarded, regardless of its length. If the application was expecting an empty payload and wants to verify that, then <em>payload</em> should point to a non-NULL zero-length buffer.</p>
<p>The <em>mesaage</em> and <em>payload</em> buffers must not overlap in memory.</p>
<p>The <em>message</em> buffer will be modified by this function to decrypt sub-components while it is being processed. The contents will be cleared just before the function exits to avoid leaking decrypted message data other than the <em>payload</em>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gafdb5b38ecaf77c7c39e0aad49cf880b6" title="Writes a message payload using a HandshakeState. ">noise_handshakestate_write_message()</a>, <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l01253">1253</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafca896117ad9a8697a3fe385deb3c280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_set_pre_shared_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pre shared key for a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">key</td><td>Points to the pre shared key. </td></tr>
    <tr><td class="paramname">key_len</td><td>The length of the <em>key</em> in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>key</em> is NULL. </dd>
<dd>
NOISE_ERROR_NOT_APPLICABLE if the protocol name does not begin with "NoisePSK". </dd>
<dd>
NOISE_ERROR_INVALID_STATE if this function is called afer the protocol has already started, or the pre shared key was already set.</dd></dl>
<p>If the prologue has not been set yet, then calling this function will implicitly set the prologue to the empty sequence and it will no longer be possible to specify an explicit prologue.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0" title="Starts the handshake on a HandshakeState object. ">noise_handshakestate_start()</a>, <a class="el" href="group__handshakestate.html#gaaf1a461a40326f8db0b7a537dc63e6fa" title="Sets the prologue for a HandshakeState. ">noise_handshakestate_set_prologue()</a>, <a class="el" href="group__handshakestate.html#ga7bf0e9e6b6d77262b579e5c3430f9a93" title="Determine if a HandshakeState object requires a pre shared key. ">noise_handshakestate_needs_pre_shared_key()</a>, <a class="el" href="group__handshakestate.html#ga0cf8228683e002acff6690a000c12854" title="Determine if a HandshakeState object has already been configured with a pre shared key...">noise_handshakestate_has_pre_shared_key()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00437">437</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf1a461a40326f8db0b7a537dc63e6fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_set_prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>prologue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prologue_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the prologue for a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">prologue</td><td>Points to the prologue value. </td></tr>
    <tr><td class="paramname">prologue_len</td><td>The length of the <em>prologue</em> value in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>prologue</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if this function is called afer <a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280" title="Sets the pre shared key for a HandshakeState. ">noise_handshakestate_set_pre_shared_key()</a> or after the protocol has already started.</dd></dl>
<p>This function must be called immediately after <a class="el" href="group__handshakestate.html#gab0b47aa4e0577b68ad90848565c00a8b" title="Creates a new HandshakeState object by protocol identifier. ">noise_handshakestate_new_by_id()</a> or <a class="el" href="group__handshakestate.html#ga0e6235ea4b4c8c434417172a764bf76c" title="Creates a new HandshakeState object by protocol name. ">noise_handshakestate_new_by_name()</a> if there is a prologue for the session. If the function is not called, then the prologue will be assumed to be empty when the protocol starts.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0" title="Starts the handshake on a HandshakeState object. ">noise_handshakestate_start()</a>, <a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280" title="Sets the pre shared key for a HandshakeState. ">noise_handshakestate_set_pre_shared_key()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00490">490</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae8480d1f1782d27eb6187075f1170dfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cipherstate.html#gaed43ed8af5dd6f1a8ce2246c5bb00dc1">NoiseCipherState</a> **&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cipherstate.html#gaed43ed8af5dd6f1a8ce2246c5bb00dc1">NoiseCipherState</a> **&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the transport encryption CipherState objects out of this HandshakeState object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">c1</td><td>Points to the variable where to place the pointer to the first CipherState object. Must not be NULL. </td></tr>
    <tr><td class="paramname">c2</td><td>Points to the variable where to place the pointer to the second CipherState object. This can be NULL if the application is using a one-way handshake pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if one of <em>state</em> or <em>c1</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the <em>state</em> has already been split or the handshake protocol has not completed successfully yet. </dd>
<dd>
NOISE_ERROR_NO_MEMORY if there is insufficient memory to create the new CipherState objects.</dd></dl>
<p>Once a HandshakeState has been split, it is effectively finished and cannot be used for future handshake operations. If those operations are invoked, the relevant functions will return NOISE_ERROR_INVALID_STATE.</p>
<p>The <em>c1</em> object should be used to protect messages from the initiator to the responder, and the <em>c2</em> object should be used to protect messages from the responder to the initiator.</p>
<p>If the handshake pattern is one-way, then the application should call <a class="el" href="group__cipherstate.html#ga407f8ce7855758296400eff1eb6c065a" title="Frees a CipherState object after destroying all sensitive material. ">noise_cipherstate_free()</a> on <em>c2</em> as it will not be needed. Alternatively, the application can pass NULL to <a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb" title="Splits the transport encryption CipherState objects out of this HandshakeState object. ">noise_handshakestate_split()</a> as the <em>c2</em> argument and the second CipherState will not be created at all.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga25cdb5ceb457746f8bf5c99d3596bd00" title="Gets the handshake hash value once the handshake ends. ">noise_handshakestate_get_handshake_hash()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l01312">1312</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf76831b18d6d95f7f47986d2c8f873c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the handshake on a HandshakeState object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> is NULL. </dd>
<dd>
NOISE_ERROR_LOCAL_KEY_REQUIRED if a local keypair is required to start the protocol but one has not been provided yet. </dd>
<dd>
NOISE_ERROR_REMOTE_KEY_REQUIRED if a remote public key is required to start the protocol but one has not been provided yet. </dd>
<dd>
NOISE_ERROR_PSK_REQUIRED if a pre shared key is required to start the protocol but one has not been provided yet. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the protocol handshake has already started. </dd>
<dd>
NOISE_ERROR_NOT_APPLICABLE if an attempt was made to start a "XXfallback" handshake pattern without first calling <a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603" title="Falls back to the &quot;XXfallback&quot; handshake pattern. ">noise_handshakestate_fallback()</a> on a previous "IK" handshake.</dd></dl>
<p>This function is called after all of the handshake parameters have been provided to the HandshakeState object. This function should be followed by calls to noise_handshake_write_message() or noise_handshake_read_message() to process the handshake messages. The <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a> function indicates the action to take next.</p>
<dl class="section see"><dt>See Also</dt><dd>noise_handshake_write_message(), noise_handshake_read_message(), <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a>, <a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603" title="Falls back to the &quot;XXfallback&quot; handshake pattern. ">noise_handshakestate_fallback()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00644">644</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafdb5b38ecaf77c7c39e0aad49cf880b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_write_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__handshakestate.html#ga00fef5d2b365025653ceea29f9fcd8d5">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> *&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a message payload using a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">message</td><td>Points to the message buffer to be populated with handshake details and the message payload. </td></tr>
    <tr><td class="paramname">payload</td><td>Points to the message payload to be sent, which can be NULL if no payload is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>message</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a> is not NOISE_ACTION_WRITE_MESSAGE. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if <em>message</em> is too small to contain all of the bytes that need to be written to it.</dd></dl>
<p>The <em>message</em> and <em>payload</em> buffers must not overlap in memory.</p>
<p>The following example demonstrates how to write a handshake message into the application's <code>msgbuf</code> array:</p>
<div class="fragment"><div class="line"><a class="code" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> payload;</div>
<div class="line">uint8_t payloadbuf[PAYLOAD_LEN];</div>
<div class="line"><span class="comment">// Format the message payload into &quot;payloadbuf&quot;.</span></div>
<div class="line"><a class="code" href="group__buffer__management.html#ga7a5d69268f76c489102ac9b4a3eebed6">noise_buffer_set_input</a>(payload, payloadbuf, <span class="keyword">sizeof</span>(payloadbuf));</div>
<div class="line"></div>
<div class="line">uint8_t msgbuf[MSGBUF_MAX];</div>
<div class="line"><a class="code" href="group__buffer__management.html#structNoiseBuffer">NoiseBuffer</a> message;</div>
<div class="line"><a class="code" href="group__buffer__management.html#ga290fa55cf78559cca92a28b12ddb8161">noise_buffer_set_output</a>(message, msgbuf, <span class="keyword">sizeof</span>(msgbuf));</div>
<div class="line">err = <a class="code" href="group__handshakestate.html#gafdb5b38ecaf77c7c39e0aad49cf880b6">noise_handshakestate_write_message</a>(state, &amp;message, &amp;payload);</div>
<div class="line"><span class="comment">// Transmit the message.size bytes starting at message.data if no error.</span></div>
</div><!-- fragment --><dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga5b86560fccec5c8d9051fa6e30e7cb20" title="Reads a message payload using a HandshakeState. ">noise_handshakestate_read_message()</a>, <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l01046">1046</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 14 2016 08:30:20 for Noise-C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
