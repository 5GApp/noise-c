<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Noise-C: HandshakeState API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Noise-C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HandshakeState API</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaaf2e6ef61771c7fa5c4f5d5e106c603"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603">noise_handshakestate_fallback</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:gaaaf2e6ef61771c7fa5c4f5d5e106c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Falls back to the "XXfallback" handshake pattern.  <a href="#gaaaf2e6ef61771c7fa5c4f5d5e106c603">More...</a><br/></td></tr>
<tr class="separator:gaaaf2e6ef61771c7fa5c4f5d5e106c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee4331d10a6c28bd336bfdf1017346d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga1ee4331d10a6c28bd336bfdf1017346d">noise_handshakestate_free</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga1ee4331d10a6c28bd336bfdf1017346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a HandshakeState object after destroying all sensitive material.  <a href="#ga1ee4331d10a6c28bd336bfdf1017346d">More...</a><br/></td></tr>
<tr class="separator:ga1ee4331d10a6c28bd336bfdf1017346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34e785f9102ce47f97292bbb897ace66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66">noise_handshakestate_get_action</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga34e785f9102ce47f97292bbb897ace66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next action the application should perform for the handshake phase of the protocol.  <a href="#ga34e785f9102ce47f97292bbb897ace66">More...</a><br/></td></tr>
<tr class="separator:ga34e785f9102ce47f97292bbb897ace66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af0bf12c96dc1eedeee92e9be8930b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga0af0bf12c96dc1eedeee92e9be8930b0">noise_handshakestate_get_dh_id</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga0af0bf12c96dc1eedeee92e9be8930b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Diffie-Hellman algorithm identifier for a HandshakeState object.  <a href="#ga0af0bf12c96dc1eedeee92e9be8930b0">More...</a><br/></td></tr>
<tr class="separator:ga0af0bf12c96dc1eedeee92e9be8930b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d4fbea908c084e46a655258dccb8108"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga4d4fbea908c084e46a655258dccb8108">noise_handshakestate_get_private_key_length</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga4d4fbea908c084e46a655258dccb8108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of the Diffie-Hellman private keys for a HandshakeObject object.  <a href="#ga4d4fbea908c084e46a655258dccb8108">More...</a><br/></td></tr>
<tr class="separator:ga4d4fbea908c084e46a655258dccb8108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba0bc0e82c4ec5cbbb1a7be41164959"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga8ba0bc0e82c4ec5cbbb1a7be41164959">noise_handshakestate_get_protocol_id</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state, <a class="el" href="group__names.html#structNoiseProtocolId">NoiseProtocolId</a> *id)</td></tr>
<tr class="memdesc:ga8ba0bc0e82c4ec5cbbb1a7be41164959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the protocol identifier associated with a HandshakeState object.  <a href="#ga8ba0bc0e82c4ec5cbbb1a7be41164959">More...</a><br/></td></tr>
<tr class="separator:ga8ba0bc0e82c4ec5cbbb1a7be41164959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1b83ef986b89151c67efcd55eb7ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga3e1b83ef986b89151c67efcd55eb7ceb">noise_handshakestate_get_public_key_length</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga3e1b83ef986b89151c67efcd55eb7ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the length of the Diffie-Hellman public keys for a HandshakeObject object.  <a href="#ga3e1b83ef986b89151c67efcd55eb7ceb">More...</a><br/></td></tr>
<tr class="separator:ga3e1b83ef986b89151c67efcd55eb7ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b077cb39d4b5754d20810e800001bdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga8b077cb39d4b5754d20810e800001bdd">noise_handshakestate_get_remote_public_key</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state, uint8_t *public_key, size_t public_key_len)</td></tr>
<tr class="memdesc:ga8b077cb39d4b5754d20810e800001bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the remote public key for a HandshakeState.  <a href="#ga8b077cb39d4b5754d20810e800001bdd">More...</a><br/></td></tr>
<tr class="separator:ga8b077cb39d4b5754d20810e800001bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae67e24a470c7f6a24f0aa24991114b92"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gae67e24a470c7f6a24f0aa24991114b92">noise_handshakestate_get_role</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:gae67e24a470c7f6a24f0aa24991114b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the role that a HandshakeState object is playing.  <a href="#gae67e24a470c7f6a24f0aa24991114b92">More...</a><br/></td></tr>
<tr class="separator:gae67e24a470c7f6a24f0aa24991114b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3667a7038035ae31cd7629ed13f99d39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga3667a7038035ae31cd7629ed13f99d39">noise_handshakestate_has_local_keypair</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga3667a7038035ae31cd7629ed13f99d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState has been configured with a local keypair.  <a href="#ga3667a7038035ae31cd7629ed13f99d39">More...</a><br/></td></tr>
<tr class="separator:ga3667a7038035ae31cd7629ed13f99d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d077b55567c999bfda4662515e3154"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga46d077b55567c999bfda4662515e3154">noise_handshakestate_has_remote_public_key</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga46d077b55567c999bfda4662515e3154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState has a remote public key.  <a href="#ga46d077b55567c999bfda4662515e3154">More...</a><br/></td></tr>
<tr class="separator:ga46d077b55567c999bfda4662515e3154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7d3a6990a63b42f86109f5044c9f4d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gac7d3a6990a63b42f86109f5044c9f4d6">noise_handshakestate_needs_local_keypair</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:gac7d3a6990a63b42f86109f5044c9f4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState still needs to be configured with a local keypair.  <a href="#gac7d3a6990a63b42f86109f5044c9f4d6">More...</a><br/></td></tr>
<tr class="separator:gac7d3a6990a63b42f86109f5044c9f4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d88e66873413c052b05f7ad35827f1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga9d88e66873413c052b05f7ad35827f1b">noise_handshakestate_needs_remote_public_key</a> (const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:ga9d88e66873413c052b05f7ad35827f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a HandshakeState still needs to be configured with a remote public key before the protocol can start.  <a href="#ga9d88e66873413c052b05f7ad35827f1b">More...</a><br/></td></tr>
<tr class="separator:ga9d88e66873413c052b05f7ad35827f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b47aa4e0577b68ad90848565c00a8b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gab0b47aa4e0577b68ad90848565c00a8b">noise_handshakestate_new_by_id</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> **state, const <a class="el" href="group__names.html#structNoiseProtocolId">NoiseProtocolId</a> *protocol_id, int role)</td></tr>
<tr class="memdesc:gab0b47aa4e0577b68ad90848565c00a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new HandshakeState object by protocol identifier.  <a href="#gab0b47aa4e0577b68ad90848565c00a8b">More...</a><br/></td></tr>
<tr class="separator:gab0b47aa4e0577b68ad90848565c00a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e6235ea4b4c8c434417172a764bf76c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga0e6235ea4b4c8c434417172a764bf76c">noise_handshakestate_new_by_name</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> **state, const char *protocol_name, int role)</td></tr>
<tr class="memdesc:ga0e6235ea4b4c8c434417172a764bf76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new HandshakeState object by protocol name.  <a href="#ga0e6235ea4b4c8c434417172a764bf76c">More...</a><br/></td></tr>
<tr class="separator:ga0e6235ea4b4c8c434417172a764bf76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3144c363d2a3772d65e4b6fb4559c78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gad3144c363d2a3772d65e4b6fb4559c78">noise_handshakestate_read_message</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state, const uint8_t *message, size_t message_size, void *payload, size_t *payload_size)</td></tr>
<tr class="memdesc:gad3144c363d2a3772d65e4b6fb4559c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a message payload using a HandshakeState.  <a href="#gad3144c363d2a3772d65e4b6fb4559c78">More...</a><br/></td></tr>
<tr class="separator:gad3144c363d2a3772d65e4b6fb4559c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55e2b8605720f23acf994aae85749156"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga55e2b8605720f23acf994aae85749156">noise_handshakestate_set_local_keypair</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state, const uint8_t *private_key, size_t private_key_len, const uint8_t *public_key, size_t public_key_len)</td></tr>
<tr class="memdesc:ga55e2b8605720f23acf994aae85749156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the local keypair for a HandshakeState.  <a href="#ga55e2b8605720f23acf994aae85749156">More...</a><br/></td></tr>
<tr class="separator:ga55e2b8605720f23acf994aae85749156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca896117ad9a8697a3fe385deb3c280"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280">noise_handshakestate_set_pre_shared_key</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state, const uint8_t *key, size_t key_len)</td></tr>
<tr class="memdesc:gafca896117ad9a8697a3fe385deb3c280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the pre shared key for a HandshakeState.  <a href="#gafca896117ad9a8697a3fe385deb3c280">More...</a><br/></td></tr>
<tr class="separator:gafca896117ad9a8697a3fe385deb3c280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf1a461a40326f8db0b7a537dc63e6fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gaaf1a461a40326f8db0b7a537dc63e6fa">noise_handshakestate_set_prologue</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state, const void *prologue, size_t prologue_len)</td></tr>
<tr class="memdesc:gaaf1a461a40326f8db0b7a537dc63e6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the prologue for a HandshakeState.  <a href="#gaaf1a461a40326f8db0b7a537dc63e6fa">More...</a><br/></td></tr>
<tr class="separator:gaaf1a461a40326f8db0b7a537dc63e6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20c6d21e20d440c46df2848439a90224"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga20c6d21e20d440c46df2848439a90224">noise_handshakestate_set_remote_public_key</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state, const uint8_t *public_key, size_t public_key_len)</td></tr>
<tr class="memdesc:ga20c6d21e20d440c46df2848439a90224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the remote public key for a HandshakeState.  <a href="#ga20c6d21e20d440c46df2848439a90224">More...</a><br/></td></tr>
<tr class="separator:ga20c6d21e20d440c46df2848439a90224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8480d1f1782d27eb6187075f1170dfb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb">noise_handshakestate_split</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state, <a class="el" href="cipherstate_8h.html#aef177dafa2e9f1e80965d96871e48a27">NoiseCipherState</a> **c1, <a class="el" href="cipherstate_8h.html#aef177dafa2e9f1e80965d96871e48a27">NoiseCipherState</a> **c2)</td></tr>
<tr class="memdesc:gae8480d1f1782d27eb6187075f1170dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the transport encryption CipherState objects out of this HandshakeState object.  <a href="#gae8480d1f1782d27eb6187075f1170dfb">More...</a><br/></td></tr>
<tr class="separator:gae8480d1f1782d27eb6187075f1170dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76831b18d6d95f7f47986d2c8f873c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0">noise_handshakestate_start</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state)</td></tr>
<tr class="memdesc:gaf76831b18d6d95f7f47986d2c8f873c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts the handshake on a HandshakeState object.  <a href="#gaf76831b18d6d95f7f47986d2c8f873c0">More...</a><br/></td></tr>
<tr class="separator:gaf76831b18d6d95f7f47986d2c8f873c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305a81df454bd2cd2b039061e79849a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__handshakestate.html#ga305a81df454bd2cd2b039061e79849a8">noise_handshakestate_write_message</a> (<a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *state, const void *payload, size_t payload_size, uint8_t *message, size_t *message_size)</td></tr>
<tr class="memdesc:ga305a81df454bd2cd2b039061e79849a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message payload using a HandshakeState.  <a href="#ga305a81df454bd2cd2b039061e79849a8">More...</a><br/></td></tr>
<tr class="separator:ga305a81df454bd2cd2b039061e79849a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="fragment"><div class="line"><a class="code" href="internal_8h.html#structNoiseHandshakeState__s">NoiseHandshakeState</a> *state;</div>
<div class="line"><a class="code" href="group__handshakestate.html#ga0e6235ea4b4c8c434417172a764bf76c">noise_handshakestate_new_by_name</a></div>
<div class="line">     (&amp;state, <span class="stringliteral">&quot;NoisePSK_XX_25519_ChaChaPoly_BLAKE2s&quot;</span>, <a class="code" href="group__roles.html#gad6265b662278a9f9b1523c55b6d0080d">NOISE_ROLE_INITIATOR</a>);</div>
<div class="line"><a class="code" href="group__handshakestate.html#gaaf1a461a40326f8db0b7a537dc63e6fa">noise_handshakestate_set_prologue</a>(state, prologue, <span class="keyword">sizeof</span>(prologue));</div>
<div class="line">noise_handshakestate_set_psk(state, psk, <span class="keyword">sizeof</span>(psk));</div>
</div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaaaf2e6ef61771c7fa5c4f5d5e106c603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_fallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Falls back to the "XXfallback" handshake pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on error. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the previous protocol has not been started or has not reached the fallback position yet. </dd>
<dd>
NOISE_ERROR_NOT_APPLICABLE if the handshake pattern in the original protocol name was not "IK".</dd></dl>
<p>This function is used to help implement the "Noise Pipes" protocol. It resets a HandshakeState object with the handshake pattern "IK", converting it into an object with the handshake pattern "XXfallback". Information from the previous session such as the local keypair and the initiator's ephemeral key are passed to the new session.</p>
<p>This function also reverses the roles of the communicating parties. The previous initiator becomes the responder and the previous responder becomes the initiator.</p>
<p>Once the fallback has been initiated, the application must call <a class="el" href="group__handshakestate.html#gaaf1a461a40326f8db0b7a537dc63e6fa" title="Sets the prologue for a HandshakeState. ">noise_handshakestate_set_prologue()</a> and <a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280" title="Sets the pre shared key for a HandshakeState. ">noise_handshakestate_set_pre_shared_key()</a> again to re-establish the early handshake details. The application can then call <a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0" title="Starts the handshake on a HandshakeState object. ">noise_handshakestate_start()</a> to restart the handshake from where it left off before the fallback.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0" title="Starts the handshake on a HandshakeState object. ">noise_handshakestate_start()</a>, <a class="el" href="group__handshakestate.html#gae67e24a470c7f6a24f0aa24991114b92" title="Gets the role that a HandshakeState object is playing. ">noise_handshakestate_get_role()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00656">656</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga1ee4331d10a6c28bd336bfdf1017346d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a HandshakeState object after destroying all sensitive material. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> is NULL.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gab0b47aa4e0577b68ad90848565c00a8b" title="Creates a new HandshakeState object by protocol identifier. ">noise_handshakestate_new_by_id()</a>, <a class="el" href="group__handshakestate.html#ga0e6235ea4b4c8c434417172a764bf76c" title="Creates a new HandshakeState object by protocol name. ">noise_handshakestate_new_by_name()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00259">259</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga34e785f9102ce47f97292bbb897ace66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_action </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next action the application should perform for the handshake phase of the protocol. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ACTION_NONE if no action needs to be taken by the application because the protocol hasn't started yet. </dd>
<dd>
NOISE_ACTION_WRITE_MESSAGE if the application is expected to write a new message payload for the next outgoing handshake message using <a class="el" href="group__handshakestate.html#ga305a81df454bd2cd2b039061e79849a8" title="Writes a message payload using a HandshakeState. ">noise_handshakestate_write_message()</a>. </dd>
<dd>
NOISE_ACTION_READ_MESSAGE if the application is expected wait for an incoming handshake message from the remote party and then pass the message to <a class="el" href="group__handshakestate.html#gad3144c363d2a3772d65e4b6fb4559c78" title="Reads a message payload using a HandshakeState. ">noise_handshakestate_read_message()</a> to extract the payload. </dd>
<dd>
NOISE_ACTION_SPLIT if the handshake has finished successfully and the application should call <a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb" title="Splits the transport encryption CipherState objects out of this HandshakeState object. ">noise_handshakestate_split()</a> to obtain the CipherState objects for the data phase of the protocol. </dd>
<dd>
NOISE_ACTION_FAILED if the handshake has failed with a MAC error. The application should destroy the HandshakeState by calling <a class="el" href="group__handshakestate.html#ga1ee4331d10a6c28bd336bfdf1017346d" title="Frees a HandshakeState object after destroying all sensitive material. ">noise_handshakestate_free()</a> and terminate the connection. If the application is using Noise Pipes, then it may be able to continue by calling <a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603" title="Falls back to the &quot;XXfallback&quot; handshake pattern. ">noise_handshakestate_fallback()</a> depending upon where in the protocol the failure occurred.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga305a81df454bd2cd2b039061e79849a8" title="Writes a message payload using a HandshakeState. ">noise_handshakestate_write_message()</a>, <a class="el" href="group__handshakestate.html#gad3144c363d2a3772d65e4b6fb4559c78" title="Reads a message payload using a HandshakeState. ">noise_handshakestate_read_message()</a>, <a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb" title="Splits the transport encryption CipherState objects out of this HandshakeState object. ">noise_handshakestate_split()</a>, <a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603" title="Falls back to the &quot;XXfallback&quot; handshake pattern. ">noise_handshakestate_fallback()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00691">691</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0af0bf12c96dc1eedeee92e9be8930b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_dh_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the Diffie-Hellman algorithm identifier for a HandshakeState object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The DH algorithm identifier, or NOISE_DH_NONE if <em>state</em> is NULL.</dd></dl>
<p>This is a convenience function, which is more efficient than calling <a class="el" href="group__handshakestate.html#ga8ba0bc0e82c4ec5cbbb1a7be41164959" title="Gets the protocol identifier associated with a HandshakeState object. ">noise_handshakestate_get_protocol_id()</a> to obtain the DH identifier.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga8ba0bc0e82c4ec5cbbb1a7be41164959" title="Gets the protocol identifier associated with a HandshakeState object. ">noise_handshakestate_get_protocol_id()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00327">327</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d4fbea908c084e46a655258dccb8108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_private_key_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of the Diffie-Hellman private keys for a HandshakeObject object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the private key in bytes, or 0 if <em>state</em> is NULL.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga3e1b83ef986b89151c67efcd55eb7ceb" title="Gets the length of the Diffie-Hellman public keys for a HandshakeObject object. ">noise_handshakestate_get_public_key_length()</a>, <a class="el" href="group__handshakestate.html#ga0af0bf12c96dc1eedeee92e9be8930b0" title="Gets the Diffie-Hellman algorithm identifier for a HandshakeState object. ">noise_handshakestate_get_dh_id()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00344">344</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ba0bc0e82c4ec5cbbb1a7be41164959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_protocol_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__names.html#structNoiseProtocolId">NoiseProtocolId</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the protocol identifier associated with a HandshakeState object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">id</td><td>Return buffer for the protocol identifier, which consists of fields that identify the cipher algorithm, hash algorith, handshake pattern, etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>id</em> is NULL.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga0af0bf12c96dc1eedeee92e9be8930b0" title="Gets the Diffie-Hellman algorithm identifier for a HandshakeState object. ">noise_handshakestate_get_dh_id()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00303">303</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3e1b83ef986b89151c67efcd55eb7ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_public_key_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the length of the Diffie-Hellman public keys for a HandshakeObject object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the public key in bytes, or 0 if <em>state</em> is NULL.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga4d4fbea908c084e46a655258dccb8108" title="Gets the length of the Diffie-Hellman private keys for a HandshakeObject object. ">noise_handshakestate_get_private_key_length()</a>, <a class="el" href="group__handshakestate.html#ga0af0bf12c96dc1eedeee92e9be8930b0" title="Gets the Diffie-Hellman algorithm identifier for a HandshakeState object. ">noise_handshakestate_get_dh_id()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00361">361</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8b077cb39d4b5754d20810e800001bdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_remote_public_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>public_key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the remote public key for a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">public_key</td><td>Points to the buffer to fill with the public key. </td></tr>
    <tr><td class="paramname">public_key_len</td><td>The length of the <em>public_key</em> buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>public_key</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if <em>public_key_len</em> is incorrect for the Diffie-Hellman algorithm in the protocol name. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the remote public key is not available.</dd></dl>
<p>The remote public key may be provided by the local party with a call to <a class="el" href="group__handshakestate.html#ga20c6d21e20d440c46df2848439a90224" title="Sets the remote public key for a HandshakeState. ">noise_handshakestate_set_remote_public_key()</a>, or it may be provided by the remote party itself during the handshake.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga20c6d21e20d440c46df2848439a90224" title="Sets the remote public key for a HandshakeState. ">noise_handshakestate_set_remote_public_key()</a>, <a class="el" href="group__handshakestate.html#ga46d077b55567c999bfda4662515e3154" title="Determine if a HandshakeState has a remote public key. ">noise_handshakestate_has_remote_public_key()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00559">559</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae67e24a470c7f6a24f0aa24991114b92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_get_role </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the role that a HandshakeState object is playing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns one of NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER if <em>state</em> is non-NULL, or zero if <em>state</em> is NULL. </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00284">284</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3667a7038035ae31cd7629ed13f99d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_has_local_keypair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState has been configured with a local keypair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the <em>state</em> has already been configured with a local keypair, or 0 if the keypair is yet to be provided. Also returns zero if <em>state</em> is NULL.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gac7d3a6990a63b42f86109f5044c9f4d6" title="Determine if a HandshakeState still needs to be configured with a local keypair. ">noise_handshakestate_needs_local_keypair()</a>, <a class="el" href="group__handshakestate.html#ga55e2b8605720f23acf994aae85749156" title="Sets the local keypair for a HandshakeState. ">noise_handshakestate_set_local_keypair()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00452">452</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga46d077b55567c999bfda4662515e3154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_has_remote_public_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState has a remote public key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the <em>state</em> has a remote public key, or 0 if the key is yet to be seen. Also returns zero if <em>state</em> is NULL.</dd></dl>
<p>A remote public key may either be provided ahead of time by <a class="el" href="group__handshakestate.html#ga20c6d21e20d440c46df2848439a90224" title="Sets the remote public key for a HandshakeState. ">noise_handshakestate_set_remote_public_key()</a>, or it may be provided by the remote party during the handshake.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga9d88e66873413c052b05f7ad35827f1b" title="Determine if a HandshakeState still needs to be configured with a remote public key before the protoc...">noise_handshakestate_needs_remote_public_key()</a>, <a class="el" href="group__handshakestate.html#ga20c6d21e20d440c46df2848439a90224" title="Sets the remote public key for a HandshakeState. ">noise_handshakestate_set_remote_public_key()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00532">532</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac7d3a6990a63b42f86109f5044c9f4d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_needs_local_keypair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState still needs to be configured with a local keypair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the <em>state</em> has not yet been configured with a local keypair, or 0 if the keypair has been provided or is not required at all. Also returns zero if <em>state</em> is NULL.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga3667a7038035ae31cd7629ed13f99d39" title="Determine if a HandshakeState has been configured with a local keypair. ">noise_handshakestate_has_local_keypair()</a>, <a class="el" href="group__handshakestate.html#ga55e2b8605720f23acf994aae85749156" title="Sets the local keypair for a HandshakeState. ">noise_handshakestate_set_local_keypair()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00433">433</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d88e66873413c052b05f7ad35827f1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_needs_remote_public_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a HandshakeState still needs to be configured with a remote public key before the protocol can start. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the <em>state</em> has not yet been configured with a required remote public key, or 0 if the key has been provided or is not required at all. Also returns zero if <em>state</em> is NULL.</dd></dl>
<p>This function indicates that a remote public key must be supplied before the protocol starts. If it is possible for the remote public key to be provided by the remote party during the session, then <a class="el" href="group__handshakestate.html#ga8b077cb39d4b5754d20810e800001bdd" title="Gets the remote public key for a HandshakeState. ">noise_handshakestate_get_remote_public_key()</a> can be called at the end of the handshake to get the remotely-provided value.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga46d077b55567c999bfda4662515e3154" title="Determine if a HandshakeState has a remote public key. ">noise_handshakestate_has_remote_public_key()</a>, <a class="el" href="group__handshakestate.html#ga20c6d21e20d440c46df2848439a90224" title="Sets the remote public key for a HandshakeState. ">noise_handshakestate_set_remote_public_key()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00511">511</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab0b47aa4e0577b68ad90848565c00a8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_new_by_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> **&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__names.html#structNoiseProtocolId">NoiseProtocolId</a> *&#160;</td>
          <td class="paramname"><em>protocol_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new HandshakeState object by protocol identifier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Points to the variable where to store the pointer to the new HandshakeState object. </td></tr>
    <tr><td class="paramname">protocol_id</td><td>The protocol identifier as a set of algorithm identifiers. </td></tr>
    <tr><td class="paramname">role</td><td>The role for the new object, either NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if either <em>state</em> or <em>protocol_id</em> is NULL, or <em>role</em> is not one of NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER. </dd>
<dd>
NOISE_ERROR_UNKNOWN_ID if the <em>protocol_id</em> is unknown. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the full name corresponding to <em>protocol_id</em> is too long. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the lengths of the hash output or the cipher key are incompatible. </dd>
<dd>
NOISE_ERROR_NO_MEMORY if there is insufficient memory to allocate the new HandshakeState object.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga1ee4331d10a6c28bd336bfdf1017346d" title="Frees a HandshakeState object after destroying all sensitive material. ">noise_handshakestate_free()</a>, <a class="el" href="group__handshakestate.html#ga0e6235ea4b4c8c434417172a764bf76c" title="Creates a new HandshakeState object by protocol name. ">noise_handshakestate_new_by_name()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00178">178</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e6235ea4b4c8c434417172a764bf76c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_new_by_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> **&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>protocol_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>role</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new HandshakeState object by protocol name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Points to the variable where to store the pointer to the new HandshakeState object. </td></tr>
    <tr><td class="paramname">protocol_name</td><td>The name of the Noise protocol to use. This string must be NUL-terminated. </td></tr>
    <tr><td class="paramname">role</td><td>The role for the new object, either NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if either <em>state</em> or <em>protocol_name</em> is NULL, or <em>role</em> is not one of NOISE_ROLE_INITIATOR or NOISE_ROLE_RESPONDER. </dd>
<dd>
NOISE_ERROR_UNKNOWN_NAME if the <em>protocol_name</em> is unknown. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the lengths of the hash output or the cipher key are incompatible. </dd>
<dd>
NOISE_ERROR_NO_MEMORY if there is insufficient memory to allocate the new HandshakeState object.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga1ee4331d10a6c28bd336bfdf1017346d" title="Frees a HandshakeState object after destroying all sensitive material. ">noise_handshakestate_free()</a>, <a class="el" href="group__handshakestate.html#gab0b47aa4e0577b68ad90848565c00a8b" title="Creates a new HandshakeState object by protocol identifier. ">noise_handshakestate_new_by_id()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00225">225</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad3144c363d2a3772d65e4b6fb4559c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_read_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>message_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>payload_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a message payload using a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">message</td><td>Points to the incoming handshake message to be unpacked. </td></tr>
    <tr><td class="paramname">message_size</td><td>The length of the incoming handshake message in bytes. </td></tr>
    <tr><td class="paramname">payload</td><td>Points to the buffer to fill with the message payload. This can be NULL if the application does not need the message payload. </td></tr>
    <tr><td class="paramname">payload_size</td><td>On entry, set to the number of bytes of memory that are available in <em>payload</em>. On exit, set to the number of bytes that were actually written to <em>payload</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em>, <em>message</em>, or <em>payload_size</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>payload</em> is NULL and <em>payload_size</em> is not zero. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a> is not NOISE_ACTION_READ_MESSAGE. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the <em>payload_size</em> is too small to contain all of the bytes that need to be written to <em>payload</em>. </dd>
<dd>
NOISE_ERROR_MAC_FAILURE if the <em>message</em> failed to authenticate, which terminates the handshake.</dd></dl>
<p>If <em>payload</em> is NULL, then the message payload will be authenticated but then discarded. If the application was expecting a zero-length payload, then <em>payload</em> should be non-NULL and <em>payload_size</em> should be zero.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga305a81df454bd2cd2b039061e79849a8" title="Writes a message payload using a HandshakeState. ">noise_handshakestate_write_message()</a>, <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00762">762</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga55e2b8605720f23acf994aae85749156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_set_local_keypair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>private_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>private_key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>public_key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the local keypair for a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">private_key</td><td>Points to the private key for the local keypair. </td></tr>
    <tr><td class="paramname">private_key_len</td><td>The length of the private key in bytes. </td></tr>
    <tr><td class="paramname">public_key</td><td>Points to the public key for the local keypair. </td></tr>
    <tr><td class="paramname">public_key_len</td><td>The length of the public key in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if one of <em>state</em>, <em>private_key</em>, or <em>public_key</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if <em>private_key_len</em> or <em>public_key_len</em> is incorrect for the Diffie-Hellman algorithm in the protocol name. </dd>
<dd>
NOISE_ERROR_NOT_APPLICABLE if the protocol name does not require a local keypair. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the protocol has already started.</dd></dl>
<p>If <a class="el" href="group__handshakestate.html#gac7d3a6990a63b42f86109f5044c9f4d6" title="Determine if a HandshakeState still needs to be configured with a local keypair. ">noise_handshakestate_needs_local_keypair()</a> returns a non-zero value, then this function must be called before <a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0" title="Starts the handshake on a HandshakeState object. ">noise_handshakestate_start()</a> to specify the local keypair for the session.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gac7d3a6990a63b42f86109f5044c9f4d6" title="Determine if a HandshakeState still needs to be configured with a local keypair. ">noise_handshakestate_needs_local_keypair()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00484">484</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafca896117ad9a8697a3fe385deb3c280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_set_pre_shared_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the pre shared key for a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">key</td><td>Points to the pre shared key. </td></tr>
    <tr><td class="paramname">key_len</td><td>The length of the <em>key</em> in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>key</em> is NULL. </dd>
<dd>
NOISE_ERROR_NOT_APPLICABLE if the protocol name does not begin with "NoisePSK". </dd>
<dd>
NOISE_ERROR_INVALID_STATE if this function is called afer the protocol has already started.</dd></dl>
<p>If the prologue has not been set yet, then calling this function will implicitly set the prologue to the empty sequence and it will no longer be possible to specify an explicit prologue.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0" title="Starts the handshake on a HandshakeState object. ">noise_handshakestate_start()</a>, <a class="el" href="group__handshakestate.html#gaaf1a461a40326f8db0b7a537dc63e6fa" title="Sets the prologue for a HandshakeState. ">noise_handshakestate_set_prologue()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00387">387</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf1a461a40326f8db0b7a537dc63e6fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_set_prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>prologue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prologue_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the prologue for a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">prologue</td><td>Points to the prologue value. </td></tr>
    <tr><td class="paramname">prologue_len</td><td>The length of the <em>prologue</em> value in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>prologue</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if this function is called afer <a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280" title="Sets the pre shared key for a HandshakeState. ">noise_handshakestate_set_pre_shared_key()</a> or after the protocol has already started.</dd></dl>
<p>This function must be called immediately after <a class="el" href="group__handshakestate.html#gab0b47aa4e0577b68ad90848565c00a8b" title="Creates a new HandshakeState object by protocol identifier. ">noise_handshakestate_new_by_id()</a> or <a class="el" href="group__handshakestate.html#ga0e6235ea4b4c8c434417172a764bf76c" title="Creates a new HandshakeState object by protocol name. ">noise_handshakestate_new_by_name()</a> if there is a prologue for the session. If the function is not called, then the prologue will be assumed to be empty when the protocol starts.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gaf76831b18d6d95f7f47986d2c8f873c0" title="Starts the handshake on a HandshakeState object. ">noise_handshakestate_start()</a>, <a class="el" href="group__handshakestate.html#gafca896117ad9a8697a3fe385deb3c280" title="Sets the pre shared key for a HandshakeState. ">noise_handshakestate_set_pre_shared_key()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00414">414</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga20c6d21e20d440c46df2848439a90224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_set_remote_public_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>public_key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the remote public key for a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">public_key</td><td>Points to the remote public key. </td></tr>
    <tr><td class="paramname">public_key_len</td><td>The length of the <em>public_key</em> in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> or <em>public_key</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if <em>public_key_len</em> is incorrect for the Diffie-Hellman algorithm in the protocol name. </dd>
<dd>
NOISE_ERROR_NOT_APPLICABLE if the protocol does not need a remote public key, or the remote public key is expected to be provided by the remote party during the handshake. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the protocol has already started.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#ga8b077cb39d4b5754d20810e800001bdd" title="Gets the remote public key for a HandshakeState. ">noise_handshakestate_get_remote_public_key()</a>, <a class="el" href="group__handshakestate.html#ga9d88e66873413c052b05f7ad35827f1b" title="Determine if a HandshakeState still needs to be configured with a remote public key before the protoc...">noise_handshakestate_needs_remote_public_key()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00585">585</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae8480d1f1782d27eb6187075f1170dfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cipherstate_8h.html#aef177dafa2e9f1e80965d96871e48a27">NoiseCipherState</a> **&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cipherstate_8h.html#aef177dafa2e9f1e80965d96871e48a27">NoiseCipherState</a> **&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the transport encryption CipherState objects out of this HandshakeState object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">c1</td><td>Points to the variable where to place the pointer to the first CipherState object. Must not be NULL. </td></tr>
    <tr><td class="paramname">c2</td><td>Points to the variable where to place the pointer to the second CipherState object. This can be NULL if the application is using a one-way handshake pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if one of <em>state</em> or <em>c1</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the <em>state</em> has already been split or the handshake protocol has not completed successfully yet. </dd>
<dd>
NOISE_ERROR_NO_MEMORY if there is insufficient memory to create the new CipherState objects.</dd></dl>
<p>Once a HandshakeState has been split, it is effectively finished and cannot be used for future handshake operations. If those operations are invoked, the relevant functions will return NOISE_ERROR_INVALID_STATE.</p>
<p>The <em>c1</em> object should be used to protect messages from the initiator to the responder, and the <em>c2</em> object should be used to protect messages from the responder to the initiator.</p>
<p>If the handshake pattern is one-way, then the application should call <a class="el" href="group__cipherstate.html#ga407f8ce7855758296400eff1eb6c065a" title="Frees a CipherState object after destroying all sensitive material. ">noise_cipherstate_free()</a> on <em>c2</em> as it will not be needed. Alternatively, the application can pass NULL to <a class="el" href="group__handshakestate.html#gae8480d1f1782d27eb6187075f1170dfb" title="Splits the transport encryption CipherState objects out of this HandshakeState object. ">noise_handshakestate_split()</a> as the <em>c2</em> argument and the second CipherState will not be created at all. </p>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00801">801</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf76831b18d6d95f7f47986d2c8f873c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts the handshake on a HandshakeState object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em> is NULL. </dd>
<dd>
NOISE_ERROR_REMOTE_KEY_REQUIRED if a remote public key is required to start the protocol but one has not been provided yet. </dd>
<dd>
NOISE_ERROR_LOCAL_KEY_REQUIRED if a local keypair is required to start the protocol but one has not been provided yet. </dd>
<dd>
NOISE_ERROR_PSK_REQUIRED if a pre shared key is required to start the protocol but one has not been provided yet. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if the protocol handshake was already started. </dd>
<dd>
NOISE_ERROR_NOT_APPLICABLE if an attempt was made to start a "XXfallback" handshake pattern without first calling <a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603" title="Falls back to the &quot;XXfallback&quot; handshake pattern. ">noise_handshakestate_fallback()</a> on a previous "IK" handshake.</dd></dl>
<p>This function is called after all of the handshake parameters have been provided to the HandshakeState object. This function should be followed by calls to noise_handshake_write_message() or noise_handshake_read_message() to process the messages in the handshake.</p>
<dl class="section see"><dt>See Also</dt><dd>noise_handshake_write_message(), noise_handshake_read_message(), <a class="el" href="group__handshakestate.html#gaaaf2e6ef61771c7fa5c4f5d5e106c603" title="Falls back to the &quot;XXfallback&quot; handshake pattern. ">noise_handshakestate_fallback()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00619">619</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga305a81df454bd2cd2b039061e79849a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int noise_handshakestate_write_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="handshakestate_8h.html#a8f8ce8fb967bdadb2656cc2ea5fff7ca">NoiseHandshakeState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>payload_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>message_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a message payload using a HandshakeState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The HandshakeState object. </td></tr>
    <tr><td class="paramname">payload</td><td>Points to the message payload to be sent, which can be NULL if <em>payload_size</em> is zero. </td></tr>
    <tr><td class="paramname">payload_size</td><td>The size of the message payload in bytes. </td></tr>
    <tr><td class="paramname">message</td><td>Points to the message buffer to be populated with handshake details and the message payload. </td></tr>
    <tr><td class="paramname">message_size</td><td>On entry, set to the number of bytes of memory that are available in <em>message</em>. On exit, set to the number of bytes that were actually written to <em>message</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOISE_ERROR_NONE on success. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>state</em>, <em>message</em>, or <em>message_size</em> is NULL. </dd>
<dd>
NOISE_ERROR_INVALID_PARAM if <em>payload</em> is NULL and <em>payload_size</em> is not zero. </dd>
<dd>
NOISE_ERROR_INVALID_STATE if <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a> is not NOISE_ACTION_WRITE_MESSAGE. </dd>
<dd>
NOISE_ERROR_INVALID_LENGTH if the <em>message_size</em> is too small to contain all of the bytes that need to be written to <em>message</em>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__handshakestate.html#gad3144c363d2a3772d65e4b6fb4559c78" title="Reads a message payload using a HandshakeState. ">noise_handshakestate_read_message()</a>, <a class="el" href="group__handshakestate.html#ga34e785f9102ce47f97292bbb897ace66" title="Gets the next action the application should perform for the handshake phase of the protocol...">noise_handshakestate_get_action()</a> </dd></dl>

<p>Definition at line <a class="el" href="handshakestate_8c_source.html#l00723">723</a> of file <a class="el" href="handshakestate_8c_source.html">handshakestate.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 13 2016 06:12:16 for Noise-C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
